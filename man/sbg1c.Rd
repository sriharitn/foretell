% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sbg1c.R
\name{sbg1c}
\alias{sbg1c}
\title{Shifted Beta Geometric (sbg) survival: One and Done and Cure Models}
\usage{
sbg1c(
  surv_value,
  h,
  N0 = NULL,
  one_and_done = FALSE,
  cure = FALSE,
  starts_m = 0.6,
  starts_q = 0.1,
  starts_d = 0.05,
  starts_cure = 0.05,
  compute_se = TRUE,
  input = c("auto", "percent", "count"),
  percent_tol = 1e-08,
  boundary_tol = 0.001
)
}
\arguments{
\item{surv_value}{Numeric survival series (percent starting at 100, or counts).}

\item{h}{Integer forecast horizon (>= 0).}

\item{N0}{Cohort size if `input = "percent"`.}

\item{one_and_done}{Logical; include one-and-done parameter \eqn{d}.}

\item{cure}{Logical; include cure fraction parameter (fraction never churning).}

\item{starts_m, starts_q}{Starting values for \eqn{m,q} on the original scale in \eqn{(0,1)}.}

\item{starts_d, starts_cure}{Starting values for \eqn{d} and \eqn{\pi} on the original scale in \eqn{[0,1]}.}

\item{compute_se}{Logical; compute robust SEs via Hessian + delta method.}

\item{input}{One of `"auto"`, `"percent"`, `"count"`. If `"auto"`, infer from `surv_value` and `N0`.}

\item{percent_tol, boundary_tol}{Tolerances for monotonicity checks and boundary SE skipping.}
}
\value{
An object of class \code{sbg_fit} with the elements shown below:
\describe{
  \item{\code{y}}{Numeric vector of observed survival values on the input scale.}
  \item{\code{input}}{Character scalar, one of \code{"input"}, \code{"percent"},
    \code{"count"}, or \code{"prob"}; echoes how \code{y} was interpreted.}
  \item{\code{N0}}{Scalar. Reference cohort size used for count/percent scaling.}
  \item{\code{flags}}{Named logical vector with model switches, e.g.
    \code{c(one_and_done = TRUE/FALSE, cure = TRUE/FALSE)}.}
  \item{\code{coef_params}}{Named numeric vector of parameters on the natural scale.
    For sBG: \code{c(a,b)} and optionally \code{d} (one-and-done) and \code{cure}.
    For BDW: \code{c(a,b,c)} and optionally \code{d}, \code{cure}.}
  \item{\code{coef_repar}}{Named numeric vector with the mean-polarization reparameterization,
    typically \code{c(m,q)} (and \code{c} for BDW if modeled on the log/exp scale).}
  \item{\code{logits}}{Named numeric vector of unconstrained optimization variables
    (e.g., \code{theta_m}, \code{theta_q}, \code{theta_d}, \code{theta_cure}, \code{theta_c}).}
  \item{\code{fitted}}{Numeric vector \eqn{S(0{:}T_{\mathrm{obs}}-1)} on the probability scale; the in-sample fit.}
  \item{\code{projected}}{Numeric vector \eqn{S(0{:}T_{\mathrm{last}})} (fit + horizon) on the probability scale.}
  \item{\code{logLik}}{Maximized log-likelihood.}
  \item{\code{convergence}}{Optimizer return code (0 indicates successful convergence).}
  \item{\code{optim_out}}{Raw optimizer list (as returned by \code{optim()}); useful for debugging.}
  \item{\code{vcov_theta}}{Variance-covariance matrix on the unconstrained scale (logits).}
  \item{\code{vcov_params}}{Variance-covariance matrix for \code{coef_params} (delta-method mapped from \code{vcov_theta}).}
  \item{\code{vcov_repar}}{Variance-covariance matrix for \code{coef_repar} (e.g., \code{m,q}).}
  \item{\code{se_params}}{Named vector of standard errors for \code{coef_params}.}
  \item{\code{se_repar}}{Named vector of standard errors for \code{coef_repar}.}
  \item{\code{se_note}}{Character note if SEs are approximate/unstable (e.g., near-PD fix).}
}
}
\description{
Fits the shifted Beta-Geometric (sBG) survival model to a monotonically
nonincreasing survival series using unconstrained optimization (internal
reparameterization ensures \(a>0, b>0\); optional one-and-done mass \(d\)
and cure fraction).
}
\details{
The baseline sBG survival (no one-and-done, no cure) at discrete times \eqn{t=0,1,\dots} is
\deqn{S(t) = \frac{B(a, b+t)}{B(a,b)}.}
With one-and-done mass \eqn{d} and cure fraction \eqn{\pi}, survival for \eqn{t \ge 1} is
\deqn{S(t) = (1-d)\left[\pi + (1-\pi)\frac{B(a, b+t)}{B(a,b)}\right], \qquad S(0)=1.}
Parameters \eqn{(a,b)} (and optionally \eqn{d,\pi}) are estimated by maximizing the
likelihood implied by the observed survival series using an internal unconstrained
parameterization. If \code{compute_se = TRUE}, standard errors on the original scale
are obtained via the delta method.

\strong{Beta reparameterization by mean and polarization index:}
The model uses a numerically stable and interpretable reparameterization of
the Beta distribution \eqn{Beta(a,b)} in terms of a **mean**
\eqn{m \in (0,1)} and a **polarization (concentration) index**
\eqn{q \in (0,1)}.

Standard Beta density:
\deqn{f(x \mid a,b) = \frac{x^{a-1}(1-x)^{b-1}}{B(a,b)}, \quad x\in(0,1),\; a,b>0.}

Mapping to mean and polarization:
\deqn{m = \frac{a}{a+b}, \qquad q = \frac{1}{1+a+b}.}
Here, \eqn{m} is the expected probability, and \eqn{q} summarizes concentration:
small \eqn{q} means large \eqn{a+b} (high concentration); large \eqn{q}
means small \eqn{a+b} (diffuse).

Inverse mapping (used internally for estimation):
\deqn{a = m \left(\frac{1}{q}-1\right), \qquad
      b = (1-m)\left(\frac{1}{q}-1\right).}

This transformation is bijective for \eqn{m \in (0,1)}, \eqn{q \in (0,1)},
and guarantees \eqn{a>0, b>0}.

\strong{Starting values:}
The arguments \code{starts_m} and \code{starts_q} provide starting values for
\eqn{m} and \eqn{q}, respectively. They are converted to \eqn{(a,b)} via the
inverse mapping above:
\deqn{a_{\text{start}} = \text{starts\_m}\left(\frac{1}{\text{starts\_q}}-1\right), \quad
      b_{\text{start}} = \left(1-\text{starts\_m}\right)\left(\frac{1}{\text{starts\_q}}-1\right).}
This parameterization typically improves optimization stability and makes
starting values more interpretable.
}
\examples{
\dontrun{
N0 <- 500; S <- c(100, 86.9, 74.3, 65.3, 59.3, 55.1, 51.7, 49.1)
fit <- sbg1c(S, h=6, N0=N0, input="percent")
summary(fit)
plot(fit, scale="percent")
}

}
\references{
{Fader P, Hardie B. How to project customer retention. Journal of Interactive Marketing. 2007;21(1):76-90.}
}
